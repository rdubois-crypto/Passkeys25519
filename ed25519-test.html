<!DOCTYPE html>
<html>
<head>
  <title>Ed25519 Passkey Test</title>
  <style>
    body { font-family: system-ui; max-width: 600px; margin: 40px auto; padding: 20px; }
    button { padding: 12px 24px; font-size: 16px; cursor: pointer; }
    .result { margin-top: 20px; padding: 15px; border-radius: 8px; }
    .success { background: #d4edda; color: #155724; }
    .failure { background: #f8d7da; color: #721c24; }
    .info { background: #e7f1ff; color: #004085; }
  </style>
</head>
<body>
  <h1>Ed25519 Passkey Support Test</h1>
  <p>Click the button to test if your browser/platform supports Ed25519 (EdDSA) for passkeys.</p>
  <button onclick="testEd25519()">Test Ed25519 Support</button>
  <div id="result"></div>

  <script>
    async function testEd25519() {
      const resultDiv = document.getElementById('result');
      
      // Check WebAuthn availability
      if (!window.PublicKeyCredential) {
        resultDiv.innerHTML = '<div class="result failure">WebAuthn not supported in this browser.</div>';
        return;
      }

      // Ed25519 = COSE algorithm -8 (EdDSA)
      const challenge = crypto.getRandomValues(new Uint8Array(32));
      const userId = crypto.getRandomValues(new Uint8Array(16));

      const createOptions = {
        publicKey: {
          challenge,
          rp: { name: "Ed25519 Test", id: location.hostname },
          user: {
            id: userId,
            name: "test@example.com",
            displayName: "Test User"
          },
          pubKeyCredParams: [
            { type: "public-key", alg: -8 }  // EdDSA (Ed25519)
          ],
          authenticatorSelection: {
            authenticatorAttachment: "platform",
            residentKey: "preferred",
            userVerification: "preferred"
          },
          timeout: 60000,
          attestation: "direct"
        }
      };

      try {
        resultDiv.innerHTML = '<div class="result info">Testing... Please complete the passkey prompt.</div>';
        
        const credential = await navigator.credentials.create(createOptions);
        
        // Parse attestation to verify algorithm used
        const attestationObject = credential.response.attestationObject;
        const authData = parseAttestationObject(attestationObject);
        const algUsed = authData.credentialPublicKey?.alg;

        if (algUsed === -8) {
          resultDiv.innerHTML = `
            <div class="result success">
              <strong>✅ Ed25519 is SUPPORTED!</strong><br><br>
              Algorithm: EdDSA (-8)<br>
              Credential ID: ${btoa(String.fromCharCode(...new Uint8Array(credential.rawId))).slice(0, 32)}...
            </div>`;
        } else {
          resultDiv.innerHTML = `
            <div class="result failure">
              <strong>⚠️ Credential created but NOT Ed25519</strong><br><br>
              Algorithm used: ${algUsed} (expected -8 for EdDSA)
            </div>`;
        }
      } catch (err) {
        resultDiv.innerHTML = `
          <div class="result failure">
            <strong>❌ Ed25519 NOT supported</strong><br><br>
            Error: ${err.name}<br>
            ${err.message}
          </div>`;
      }
    }

    function parseAttestationObject(attestationBuffer) {
      // Simple CBOR parsing for attestation object
      const data = new Uint8Array(attestationBuffer);
      
      // Find authData (after "authData" key in CBOR map)
      const authDataMarker = [0x68, 0x61, 0x75, 0x74, 0x68, 0x44, 0x61, 0x74, 0x61]; // "authData"
      let idx = findSequence(data, authDataMarker);
      if (idx === -1) return {};
      
      idx += authDataMarker.length;
      
      // Skip CBOR byte string header
      if (data[idx] >= 0x58 && data[idx] <= 0x5b) {
        const lenBytes = data[idx] - 0x57;
        idx += 1 + lenBytes;
      } else if (data[idx] >= 0x40 && data[idx] <= 0x57) {
        idx += 1;
      }
      
      // authData: rpIdHash(32) + flags(1) + signCount(4) + attestedCredData
      const flags = data[idx + 32];
      const hasAttestedCred = (flags & 0x40) !== 0;
      
      if (!hasAttestedCred) return { flags };
      
      let pos = idx + 37; // After rpIdHash + flags + signCount
      const aaguid = data.slice(pos, pos + 16);
      pos += 16;
      
      const credIdLen = (data[pos] << 8) | data[pos + 1];
      pos += 2 + credIdLen;
      
      // Now at COSE key - parse to find algorithm
      const coseKey = parseCoseKey(data, pos);
      
      return { flags, credentialPublicKey: coseKey };
    }

    function parseCoseKey(data, start) {
      // Look for algorithm field (key 3) in COSE key map
      // Algorithm -8 = EdDSA, -7 = ES256, -257 = RS256
      let pos = start;
      if (data[pos] < 0xa0 || data[pos] > 0xbf) return {};
      
      const mapSize = data[pos] - 0xa0;
      pos++;
      
      for (let i = 0; i < mapSize && pos < data.length - 1; i++) {
        const key = data[pos] <= 0x17 ? data[pos] : (data[pos] === 0x20 ? -1 : data[pos] - 0x40);
        pos++;
        
        if (key === 3) { // Algorithm field
          // Parse negative integer
          if (data[pos] >= 0x20 && data[pos] <= 0x37) {
            return { alg: -(data[pos] - 0x20 + 1) };
          } else if (data[pos] === 0x38) {
            return { alg: -(data[pos + 1] + 1) };
          }
        }
        
        // Skip value (simplified)
        if (data[pos] >= 0x40 && data[pos] <= 0x5b) {
          const len = data[pos] <= 0x57 ? data[pos] - 0x40 : data[pos + 1];
          pos += (data[pos] <= 0x57 ? 1 : 2) + len;
        } else {
          pos++;
        }
      }
      return {};
    }

    function findSequence(arr, seq) {
      outer: for (let i = 0; i <= arr.length - seq.length; i++) {
        for (let j = 0; j < seq.length; j++) {
          if (arr[i + j] !== seq[j]) continue outer;
        }
        return i;
      }
      return -1;
    }
  </script>
</body>
</html>
